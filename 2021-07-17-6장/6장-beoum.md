# 6장 AOP

## 트랜잭션 코드의 분리

* 트랜잭션의 경계설정이 논리적으로 Service에 존재하는걸 거부할 명분은 없다.

* 하지만 트랜잭션의 경계설정 코드와 비즈니스 로직은 서로 주고받는것도 없는 완벽하게 독립적인 코드다.

* 직접 사용하는 것이 문제가 된다면 코드를 분리해 간접적으로 사용하면된다.
>  DI의 기본 아이디어가 바로 실제 사용할 오브젝트의 클래스 정체를 감춘체 인터페이스를 통해 간접으로 접근하는것!

* 같은 인터페이스를 이용한 비즈니스와 트랜잭션의 각각 구현체를 만들고 트랜잭션 구현체를 지나 실제 비즈니스 구현체를 동작(트랜잭션에서 비즈니스로 역할 위임 __위임__ ).
> 트랜잭션 구현체는 트랜잭션만 담당하고 비즈니스와 관련된 부부은 비즈니스 구현체에게 전부 위임!

* 비즈니스 코드와 트랜잭션 코드를 분리함으로써 우리가 얻는 이점?
> 비즈니스 코드를 작성할때 트랜잭션과 같은 기술적인 내용에 관심을 가지지 않아도 되고, 비즈니스 로직에 대한 테스트를 손쉽게 만들어 낼 수 있게된다.

## 고립된 단위 테스트

* 복잡한 관계속에서 테스트를 진행하게될 경우 그 어느 것이라도 바르게 셋업 되어 있지 않으면 테스트가 실패하게 되기 때문에 눈에 보이는 테스트 대상에 국한된 테스트 같지만 사실은 그뒤에 의존관계를 따른 복합적인 요소들이 합쳐져 테스트 대상이 되는것!

* 그렇기에 고립된 테스트가 필요한것이며 고립된 테스트를 하면 테스트가 다른 대상에 영향을 받을 경우를 준비할 필요도 없어지고 그에 따라 테스트 수행 성능도 향상된다.
> 테스트는 코드 자체의 테스트도 중요하지만 얼마나 자주 손쉽게 테스트를 실행할 수 있냐도 중요한 포인트라고 생각한다!

* 단위 테스트의 단위는 정하기 나름이며, 기능 전체가 단위가 될 수 있고 클래스나 메소드가 단위가 될 수 있다.
> 어쨋든 단위라는 단어를 사용할 때는 단위의 의미를 명확하게 할 피룡가 있다.

* 실제 코드를 작성한 후에 테스트 코드를 만드는 경우에도 가능한 한 빨리 작성하도록 해야한다.
> FIRST 속성의 T(Timely), 테스트를 뒤로 미루지말고 적시(즉시)에 하자!

## 다이내믹 프록시와 팩토리 빈

* 위에서 위임을 통해 비즈니스 코드와 트랜잭션 코드를 분리했지만 위임이라는 특성상 코드에 남아있는게 사실이다.

* 패턴의 사용목적이 기능의 부가인지, 접근 제어인지를 구분해서 정의하자면
    * 접근제어: 프록시
    * 기능의부가: 데코레이터
    
* 위임을 통해 모든 작업에 프록시를 적용하게 되면 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭고 수정되면 상당히 부담스러워진다.
> 구현 메소드가 3개, 4개가 아니라 30개, 40개로 늘어난다면? 그것대로 굉장히 골치아프다.

* 그래서 리플렉션을 이용해 오브젝트 내부의 속성들을 가져와 프로시를 설정하기도 한다.
> 하지만 이렇게 작업을 하게 되면 여러개의 부가기능을 적용하려고 할 때도 문제가 된다.

## 스프링의 프록시 팩토리 빈

* 위와 같은 문제들로 인해 스프링은 매우 세련되고 깔끔한 방식으로 해결할 수 있는 솔루션을 제공한다(ProxyFactoryBean).

* 스프링에서 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 __어드바이스__ 라고 부른다(타깃 오브젝트에 종속되지 않는 순수한 부가기능).

* 메소드의 이름을 가지고 부가기능을 적용 대상 메소드를 선정하는 알고리즘을 담은 객체를 포인트컷이라고 한다.

* 이런 어드바이스와 포인트컷을 묶은 오브젝트를 어드바이저라고 한다.
> 왜 두객체를 묶어서 사용할까? 만약 각각따로 사용하게 된다면 부가 기능에 대해 어떤 메소드를 선정해 적용해야할지 애매해지기 때문이다!

## 스프링 AOP

* 부가기능 형태로 제공 된다면, 마치 투명한 유리를 사이에 둔 것처럼 다른 코드에서는 그 존재가 보이지 않지만 메소드가 호출되는 과정에서 다이내미하게 부가적인 기능을 제공해야한다.

* 투명한 유리처럼 제공한다면 얼핏 보면 자동으로 동작하는것 처럼 보일 수 있는데 자동으로 돌아간다고 끝이 아니라, 한 번쯤은 직접 확인해보는 습관을 들이는것도 좋다.

* 트랜잭션과 같은 부가기능은 핵심기능과 같은 방식으로 모듈하하기가 어렵다.
> 이름 그대로 부가기능이기 때문에 스스로는 독립적인 방식으로 존재해서는 적용되기 어렵기 때문.

* 그래서 이런 부가기능 모듈을 애스팩트(Aspect)라고 부르기 시작했다.
> 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 구성 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가르킨다.

* 애스팩트라는 모듈을 만들어서 설계하는 방법을 애스펙트 지향 프로그래밍, __AOP__ 라고 부르기 시작했다.

* AOP는 OOP를 돕는 보조적인 기술이지 OOP를 오나전히 대체하는 새로운 개념은 아니다.

* AspectJ라는 기술을 사용하면 바이트코드 조작을 통해 AOP의 적용이 가능하다.
> 스프링이 관리하는 모듈이 아닌 경우(ex. myBatis) 사용할 수 있다.

## 트랜잭션 속성

* 트랜잰션의 기본개념은 쪼갤 수 없는 최소 단위의 작업이다.

* 트랜잭션 전파란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.

* 트랜잭션을 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.
> 개발자가 실수로 놓칠 수 있는 부분을 코드상에서 방지가 가능하다. 또 그만큼의 성능 향상을 가져올 수 있다.

* 트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
* 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 저장소에 보관해뒀다가 DAO에서 공유할 수 있었다.
* 트랜잭션 전파 속성에 따라서 이에 참여할 수 있도록 만들어주느 것도 태랜잭션 동기화 기술 덕분이다.

* readOnly의 테스트는 @Transactional(readOnly=true)를 통해 테스트가 가능하다.

## 결론
> 트랜잭션을 예시로 핵심로직과는 다른 부가기능을 어떻게 분리하고 유연하게 적용할 수 있는지 방법을 찾아 보았으니.
> 필요에 따라 자신의 프로젝트에 적용해보자!
