# 4장 예외

## 예외처리

* try, catch 후 catch안에서 아무것도 처리하지 않는건 정말 위험한 일이다.
<br/>=> 프로그램 실행중 어디선가 예외가 발생했는데 그걸 무시하고 진행하기 때문! 
> 습관이 되면 무서우니 코딩 연습이나 예제를 잠깐 만드는 경우에도 그러지 말자

* 또한 log만 남겨 놓는다고 예외 처리가아니다. 적절히 복구 시키던지, 작업을 중단시키던지의 행동이 필요하다.

* 굳이 예외를 잡아서 조치를 취할 방법이 없으면 잡지말고 던져라.

* error와 exception을 잘 구분하고, error의 경우 시스템 레벨에서 특별한 작업을 하는게 아니라면 처리를 신경쓰지 않아도 된다.
<br/>error: OutOfMemoryError나 ThreadDeath같은 시스템 레벨상의 개발자가 예측하지 못하는 상황
<br/>exception: 개발자가 작성한 로직에 의해 발생하는 문제!

* IOException의 메시지를 사용자에게 그대로 던지는건 예외복구 라고 할 수 없다. 예외상황이 발생할 수 있음을 인식하도록 도와주고 적절한 처리를 시도하도록 유도하도록 요구하자!
> ex) naver의 homepage의 광고들은 잠깐이라도 노출되지 않으면 금전적인 손해를 보기 때문에 Circuit Breaker Pattern을 적용해 해결한다.

## 예외처리 전략

* 내부에서 발생한 예외를 그대로 던지는 것 보다 적절한 의미를 부여해 처리해주는게 더 좋다.
> 공통 RuntimeException class를 만들어 wrapping하는것도 방법!

* application 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 게 좋다!

* 예전에는 복구할 가능성이 조금이라도 있다면 체크 예외로 만들었지만, 지금은 항상 복구할 수 있는 예외가 아니라면 언체크 예외로 만드는 경향이 있다.

## 애플리케이션 예외

* 애플리케이션에서 의도적으로 예외적인 상황을 발생시키는 것들을 __애플리케이션 예외__ 라고 한다.

* 런타임 예외 중심의 전략 == 낙관적인 태도 기반

* catch후 특별한 값을 return 하는 방법(ex. -1, -999)
> 리턴 값을 명확하게 코드화하고 관리하지 않으면 혼란이 생길여지가 다분하다.

* 대부분의 SQLException은 복구가 불가능하다.
> 필요없는 throw 선언보다 가능한한 빨리 언체크/런타임 예외로 전환해주자!

* spring의 API 메소드에 정의되어 있는 대부분의 예외는 런타임 예외이기 때문에, 발생가능한 예외가 있어도 이를 처리하도록 강제하지 않는다.


## 예외 전환

* 인터페이스를 사용하는 객체지향 프로그래밍 방법의 장점을 잘 경험할 수 있는 것이 바로 JDBC!
> OCP의 설명예제로도 자주 출현한다.

* JDBC라는 인터페이스를 벤더사에게 제공함으로 JDBC가 특정 DB에 종속되지 않도록 한다.

* DB마다 에러의 종류와 원인도 제각각이지만 그냥 SQLException하나로 담아버린다. => DB에러 코드 또한 DB별로 모두 다르다.
> DB 벤더가 정의한 고유한 에러 코드를 사용하기 때문.

<br/>

> 호환성 없는 예외코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는건 불가능에 가깝다.<br/>
> 인터페이스를 통해 기능의 추상화는 성공했지만, 예외코드와 db안에서 일어날 수 있는 일들은 추상화하지 못했기 때문?

* 벤더 별로 각각의 exception을 처리해줘야 한다면 해당 method를 사용하는곳은 벤더에 종속적으로 프로그래밍을 할 수 밖에 없다.
> 하지만 JDBC보다 이후에 나온 JDO, 하이버네이트, JPA등의 기술들은 체크 예외 대신 런타임 예외를 사용하기 때문에 throw에 선언을 해주지 않아도 된다.

* 그래도 스프링은 데이터 액세스 기술을 사용할 때 발생하는 문제를 추상화해서 DataAccessException 계층구조에 정리해두었다.
> 결국 인터페이스를 사용해, 런타임 예외를 전환하고, 추상화를 통해 구현에 독립적인 Dao를 만들 수 있다.

## DAO 인터페이스와 구현의 분리

* DAO를 굳이 따로 만들어서 사용하는 이유는?
> 데이터 엑세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서! <br/>
> DML과 DCL을 구분해서 명칭하듯이 코드상으로도 관심사의 분리가 필요.

* DAO 인터페이스를 기술에 완전히 독립적으로 만들려면 벤더별로 예외가 일치하지 않는 문제를 해결해야한다.
> 그렇다고 throw Exception 이렇게 처리하는건 간단하지만 무책임한 선언이다.(알긋냐)

* DAO를 사용하는 클라이언트 입장에선느 DAO의 사용기술에 따라서 예외 처리 방법이 달라져야한다. 결국 DAO의 기술에 의존적이게 된다.

## 결론

> 예외처리는 나와 동료들을 위해 특히나 신경써야하고, 완벽한 정답이 없는만큼 커뮤니케이션이 더욱이 필요한 부분!


