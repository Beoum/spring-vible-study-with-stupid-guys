# 5장 서비스 추상화

## 서비스 추상화
* 환경과 상황에 따라서 기술이 바뀌고, 그에따라 다른 방법으로 접근해야한다는건 매우 피곤한 일!

* JDBC가 사용하는 SQL은 컴파일 과정에서는 단순 문자열에 불과하기에, DB에 전달되기 전까지는 오류를 발견하기 어렵다.
> 콤마(,)나 스페이스바와 같이 별것 아닌것도 무심코 넘기기 쉽다. 그렇기에 빠르게 실행 가능한 포괄 테스트가 위력을 발휘하기 쉽다.

* update문을 확실히 테스트하고 싶다면 WHERE을 빼보고 실행해보자. 꼼꼼한 테스트를 만들지 않았을 때의 아찔한 결과를 한 번쯤 떠올려보고, 한번할때 제대로 만들자!
> 개발의 life cycle은 app refactoring이 끝이 아닌 이후의 test의 refactoring까지라고 생각하고 작업에 임하자.

* DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다. 
<br/>=> 비즈니스 로직을 다루는 class를 Service라는 명칭으로 분리해서 작업하자.

* 정말 뛰어난 개발자라면 아무리 간단해 보여도 실수할 수 있음을 알고 있기 때문에 테스트를 만들어서 직접 동작하는 모습을 확인하려고 한다.
> 자만하지말자.

* DB에 정보를 넣고 읽는 방법과 비즈니스적인 정보를 설정하는것의 관심사를 잘 구분하자(Dao와 Service의 구분).

* 코드가 중복되는지? 무엇을 하는 코드인지? 있어야 할 자리에 있는지? 자신의 코드를 다시 한번 검토해보자.

* 관련있어보이지만 성격이 조금씩 다른 코드들이 혼재되어 있다면 시간이 지날수록 이해하고 관리하기가 어려워지고. 지저분한 코드때문에 버그를 찾기 힘들어 진다. 결국엔 변화에 취약하고 다루기 힘든 코드가 되어 문제점을 파악하고 설명하기도 어려워진다.

* class만 단일책임의 원칙을 지켜야 한다가 아니라 method도 마찬가지라고 생각하자.

* user의 정보를 다루는 정보는 userService보다는 user가 스스로 다루게 하는게 적절하다.(ex. 비밀번호 hash)

* 또 user의 예외상황을 스스로 검증할 수 있게 하는편이 안전하다.
> userService에서만 user를 사용하지 않을 수 있기 때문이다. 객체는 나만의 세상을 가진다고 생각하자(?)

* 각각을 독립적으로 테스트하도록 만들면 테스트 코드가 단순해진다.

* 객체지향적인 코드는 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 요청한다. 이게 객체지향 프로그래밍의 가장 기본!

* 객체지향이 어쩌고 저쩌고 하는 설명이 불편하다면, 이렇게 코드를 짜면 이해하기 쉽고 변화에 유연한 코드를 만들 수 있구나라고 생각하자.
> 코드가 깔끔하고 유연하면서 테스트하기 좋게 만들도록 노력하자.

* 이것도 테스트를 해야할까 생각이 든다면 테스트를하자. 왜냐하면 아픙로 어떤 기능과 로직이 추가될지 모르니까!

* 한 가지 변경 이유가 발생했을 때 여러 군데를 고치게 만든다면 중복이다. 고치자!

* 특정 기간에만 유효한 method를 이전 코드로 수정한다는건 상당히 번거롭고 위험한 방법이니 DI로 해결하는 방법도 고민해보자.

## 트랜잭션 서비스 추상화

* 트랜잭션이란? 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.

* 데이터를 엑세스 한다는 관점으로 트랜잭션의 처리는 Dao에서 해야할 것 같지만. 이렇게되면 Dao의 메소드를 호출 할때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 되버린다.
> 결국 Service 내에서 진행되는 여러가지 작업을 하나의 트랜잭션으로 묶는게 불가능해진다.

* 그렇다고 Service에 Connection안에서 만들어지는 transaction을 처리하는 로직을 넣는다면 비즈니스로직과 데이터 로직이 한데 묶이는 한심한 결과를 초래한다.

* 그래서 스프링에서는 Service도 Dao도 아닌 __트랜잭션 동기화 방식__ 을 사용한다.
> Connection 오브젝트를 특별한 저장소에 보고나해두고, Dao가 필요에 따라 가져다 사용하도록 한다.

* 로컬 트랜잭션과 글로벌 트랜잭션이 존재한다.

* 로컬 트랜잭션은 하나의 DB Connection에 종속적이다. 하나 이상의 DB가 참여하는 트랜잭션을 만들려면 JTA를 사용하자.

* JDBC, JPA, 하이버네이트, JTA 상황에 따라 트랜잭션 처리 코드를 따로 처리 해야한다면, Service는 해당기술에 종속적으로 변해버린다. 
<br/>=> 그래서 스프링에서 트랜잭션 서비스를 추상화해 제공한다.

## 메일 서비스 추상화

* 테스트를 하면서 매번 메일이 발송되는 것이 바람직할까? 발송되는것으로 운영서버에 무리를 줄 수 있으므로 대게 바람직하지 못하다.

* 따라서 SMTP로 메일 전송 요청 테스트를 한다고 매번 메일 수신 여부를 일일이 확인 할 필요는 없고, 테스트 가능한 메일 서버까지만 잘 전송되는지 확인하면 된다.

## 테스트 대역(스텁)

* 테스트 스텁은 테스트 대상 오브텍트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는것을 말한다.

## 서비스 추상화와 단일 책임 원칙

* 서비스에 대한 추상화 기법으로 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다. 이렇게 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는건 __스프링의 DI가 중요한 역할을 한다.__
> 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는데 정말정말 좋다!

* UserService에 Connection과 관련된 코드가 들어있다라고 한다면, 사용자 레벨관리와 트랜잭션 관리라는 두가지 책임을 가지게 되어 __수정하는 이유도 두가지가 되버린다.__
> UserService가 수정되어야 할때는 사용자 관리 로직이 바뀌거나 추가될 때다(수정 대상이 명확해진다).

* 적절한 책임과 관심이 다른 코드를 분리하고 서로 영향을 주지 않도록 하기위한 핵심적인 도구는 스프링이 제공하는 __DI다.__
> DI는 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구.

## 결론

* 책 몇 권 읽고, 몇 달 노력한다고 좋은코드가 나오지 않기에 계속 다듬고 개선하려는 자세가 필요하다. 왜냐하면 알고 있다고 저절로 깔끔하고 유연한 코드가 나오는게 아니기 때문이다.
> 알지 못하면 고민의 필요성도 문제도 알지 못하기 때문에, 발전할 수 없다. 그렇기에 스스로 고민하고 노력하고 발전하기 위해서 공부해야한다.

