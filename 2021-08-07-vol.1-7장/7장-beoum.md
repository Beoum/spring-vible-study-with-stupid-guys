# 7장 스프링 핵심 기술의 응용

## SQL과 DAO의 분리
* SQL의 변경이 필요할 경우 DAO 또한 변경되어야 하기에 분리하고 관리하는게 수월하다.
    * 가장 쉽게 생각할 수 있는건 XML 설정을 이용해서 분리하는 것
        * 하지만 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이 잇다.
    * SQL만을 위한 인터페이스를 설계    
        * 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서 전혀 신경 쓸 필요가 없어진다.

> 역시나 중요한건 분리 가능한 관심사를 구분해보는 것
   
## 인터페이스의 분리와 자기 참조 빈
* 굳이 DI를 적용하지 않더라도 자신이 사용하는 오브젝트의 클래스가 어떤 것인지를 알지 못하게 만드는 것이 좋다.
<br/>=> 코드간의 결합도를 낮추는게 좋기 때문

* XML 문서를 읽어서 자바의 오브젝트로 변환하는 것을 JAXB에서는 __언마샬링__ 반대는 마샬링이라고 한다.

## 서비스 추상화 적용과 DI
* 서비스를 추상화하면 로우레벨의 기술을 필요에 따라 변경해서 사용하더라도 일관된 애플리케이션 코드를 유지할 수 있게된다.

* 편리한 확장과 변경을 위해서 클래스를 분리하고 추상화하는것도 좋지만 계속해서 늘어가는 빈의 개수와 반복되고 비슷한 DI구조가 불편해질 수도 있다.

* 오브젝트들이 서로의 세부적인 구현에 얽매이지 않고 유연한 방식으로 의존관계를 맺으며 독립적으로 발전할 수 있게 해주는건 바로 DI.

* 물론 DI에 필요한 유연하고 확장성이 뛰어난 오브젝트를 설계하는건 많은 고민과 학습, 훈련, 경험이 필요하다.

> DI란 결국 미래를 프로그래밍 하는것!

* DI에 가능한 한 인터페이스를 사용하는 이유?
    * 다형성을 얻기 위해서
    * 인터페이스 분리를 통해 오브젝트의 관계를 명확히 할 수 잇기 때문
    
> 굳이 인터페이스를 써야 하냐고 주장하는 사람을 만났을 때 논리적으로 설득할 자신이 없다면 DI는 원래 인터페이스를 쓰게 되어있다고 우겨도 좋다.

## 스프링 3.1의 DI
* 스프링에서 애노테이션의 활용이 늘어난 이유는 자바 코드와 이를 지둰하는 IoC 방식의 프레임워크 그리고 메타정보라는 세가지 구성하는 방식이 잘 어울리기 때문이다.

* XML 컨텍스트의 변경을 할때는 단계적으로 XML의 내용을 옮기다가 더 이상 아무런 DI 정보가 남아있지 않으면 그때 XML 파일을 제거하면 전환 작업이 된다.

* < bean >에 넣은 클래스는 내부적으로 리플랙션 API를 이용하기 때문에 private으로 접근을 제한해도 빈의 클래스로 사용할 수 있다.

* @Autowired는 필드의 타입의 타입을 기준으로 빈을 찾고 @Resource는 필드 이름을 기준으로 한다.

* @Component는 빈으로 등록될 후보 클래스에 붙여주는 일종의 마커(Marker)다.

> DI를 의식하면서 코드를 작성하면 객체지향 설계에 도움이 된다.
